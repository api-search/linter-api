"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.severeEnoughToFail = void 0;
const lodash_1 = require("lodash");
const spectral_core_1 = require("@stoplight/spectral-core");
const linter_1 = require("../services/linter");
const output_1 = require("../services/output");
const config_1 = require("../services/config");
const formatOptions = Object.values(config_1.OutputFormat);
const lintCommand = {
    describe: 'lint JSON/YAML documents from files or URLs',
    command: 'lint [documents..]',
    builder: yargs => yargs
        .strict()
        .positional('documents', {
        description: 'Location of JSON/YAML documents. Can be either a file, a glob or fetchable resource(s) on the web.',
        coerce(values) {
            if (Array.isArray(values) && values.length > 0) {
                return values;
            }
            if (process.stdin.isTTY) {
                return [];
            }
            return [process.stdin.fd];
        },
    })
        .check((argv) => {
        if (argv.format !== void 0 && !formatOptions.includes(String(argv.format))) {
            throw new TypeError('Unspecified format');
        }
        if (!Array.isArray(argv.documents) || argv.documents.length === 0) {
            throw new TypeError('No documents provided.');
        }
        return true;
    })
        .options({
        encoding: {
            alias: 'e',
            description: 'text encoding to use',
            type: 'string',
            default: 'utf8',
            choices: ['utf8', 'ascii', 'utf-8', 'utf16le', 'ucs2', 'ucs-2', 'base64', 'latin1'],
        },
        format: {
            alias: 'f',
            description: 'formatter to use for outputting results',
            choices: formatOptions,
            default: config_1.OutputFormat.STYLISH,
            type: 'string',
        },
        output: {
            alias: 'o',
            description: 'output to a file instead of stdout',
            type: 'string',
        },
        'stdin-filepath': {
            description: 'path to a file to pretend that stdin comes from',
            type: 'string',
        },
        resolver: {
            description: 'path to custom json-ref-resolver instance',
            type: 'string',
        },
        ruleset: {
            alias: 'r',
            description: 'path/URL to a ruleset file',
            type: 'string',
        },
        'fail-severity': {
            alias: 'F',
            description: 'results of this level or above will trigger a failure exit code',
            choices: ['error', 'warn', 'info', 'hint'],
            default: 'error',
            type: 'string',
        },
        'display-only-failures': {
            alias: 'D',
            description: 'only output results equal to or greater than --fail-severity',
            type: 'boolean',
            default: false,
        },
        'ignore-unknown-format': {
            description: 'do not warn about unmatched formats',
            type: 'boolean',
            default: false,
        },
        'fail-on-unmatched-globs': {
            description: 'fail on unmatched glob patterns',
            type: 'boolean',
            default: false,
        },
        verbose: {
            alias: 'v',
            description: 'increase verbosity',
            type: 'boolean',
        },
        quiet: {
            alias: 'q',
            description: 'no logging - output only',
            type: 'boolean',
        },
    }),
    handler: args => {
        const { documents, failSeverity, displayOnlyFailures, ruleset, stdinFilepath, format, output, encoding, ignoreUnknownFormat, failOnUnmatchedGlobs, ...config } = args;
        return (0, linter_1.lint)(documents, {
            format,
            output,
            encoding,
            ignoreUnknownFormat,
            failOnUnmatchedGlobs,
            ruleset,
            stdinFilepath,
            ...(0, lodash_1.pick)(config, ['verbose', 'quiet', 'resolver']),
        })
            .then(results => {
            if (displayOnlyFailures) {
                return filterResultsBySeverity(results, failSeverity);
            }
            return results;
        })
            .then(results => {
            if (results.length > 0) {
                process.exitCode = (0, exports.severeEnoughToFail)(results, failSeverity) ? 1 : 0;
            }
            else if (config.quiet !== true) {
                console.log(`No results with a severity of '${failSeverity}' or higher found!`);
            }
            const formattedOutput = (0, output_1.formatOutput)(results, format, { failSeverity: (0, spectral_core_1.getDiagnosticSeverity)(failSeverity) });
            return (0, output_1.writeOutput)(formattedOutput, output);
        })
            .catch(fail);
    },
};
const fail = ({ message }) => {
    console.error(message);
    process.exitCode = 2;
};
const filterResultsBySeverity = (results, failSeverity) => {
    const diagnosticSeverity = (0, spectral_core_1.getDiagnosticSeverity)(failSeverity);
    return results.filter(r => r.severity <= diagnosticSeverity);
};
const severeEnoughToFail = (results, failSeverity) => {
    const diagnosticSeverity = (0, spectral_core_1.getDiagnosticSeverity)(failSeverity);
    return results.some(r => r.severity <= diagnosticSeverity);
};
exports.severeEnoughToFail = severeEnoughToFail;
exports.default = lintCommand;
//# sourceMappingURL=lint.js.map